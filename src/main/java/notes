
    1.进程和线程

        线程是系统最小的执行单元
        同一个进程中有多个线程
        线程共享进程的资源

        线程的交互 ： 互斥和同步

    2.
      A. 无论synchronized关键字加在方法上还是对象上，如果它作用的对象是非静态的，则它取得的锁是对象；
         如果synchronized作用的对象是一个静态方法或一个类，则它取得的锁是对类，该类所有的对象同一把锁。
      B. 每个对象只有一个锁（lock）与之相关联，谁拿到这个锁谁就可以运行它所控制的那段代码。
      C. 实现同步是要很大的系统开销作为代价的，甚至可能造成死锁，所以尽量避免无谓的同步控制。

    3. synchronized 和 volatile 的可见性
        Java所有变量都存储在主内存中
        每个线程都有自己独立的工作内存，里面保存该线程的使用到的变量副本（该副本就是主内存中该变量的一份拷贝）
        （1）线程对共享变量的所有操作都必须在自己的工作内存中进行，不能直接在主内存中读写
        （2）不同线程之间无法直接访问其他线程工作内存中的变量，线程间变量值的传递需要通过主内存来完成。
            线程1对共享变量的修改，要想被线程2及时看到，必须经过如下2个过程：
           （1）把工作内存1中更新过的共享变量刷新到主内存中
           （2）将主内存中最新的共享变量的值更新到工作内存2中

         可见性：一个线程对共享变量的修改，更够及时的被其他线程看到

        synchronized:保证可见性和原子性
            synchronized规定，线程在加锁时，先清空工作内存→在主内存中拷贝最新变量的副本到工作内存→执行完代码→将更改后的共享变量的值刷新到主内存中→释放互斥锁

        Volatile：保证可见性，但不保证操作的原子性
            Volatile实现内存可见性是通过store和load指令完成的；也就是对volatile变量执行写操作时，会在写操作后加入一条store指令，即强迫线程将最新的值刷新到主内存中；
            而在读操作时，会加入一条load指令，即强迫从主内存中读入变量的值。但volatile不保证volatile变量的原子性，
            例如：
                Private int Num=0;
                Num++;//Num不是原子操作
                 Num不是原子操作，因为其可以分为：读取Num的值，将Num的值+1，写入最新的Num的值。
                    对于Num++;操作，线程1和线程2都执行一次，最后输出Num的值可能是：1或者2
                   【解释】输出结果1的解释：当线程1执行Num++;语句时，先是读入Num的值为0，倘若此时让出CPU执行权，线程获得执行，线程2会重新从主内存中，读入Num的值还是0，
                          然后线程2执行+1操作，最后把Num=1刷新到主内存中； 线程2执行完后，线程1由开始执行，但之前已经读取的Num的值0，所以它还是在0的基础上执行+1操作，
                          也就是还是等于1，并刷新到主内存中。所以最终的结果是1
                    一般在多线程中使用volatile变量，为了安全，对变量的写入操作不能依赖当前变量的值

             所以Volatile 一般适用于对当前值不依赖的情况和适用于状态标记量

     有序性--happens-before原则


     发布对象:使一个对象能够被当前范围之外的代码所使用
     对象的溢出：一种错误的发布，当一个对象还没有构造完成时，就使它被其他线程所见


    安全发布对象:(publish)
         在静态初始化函数中初始化一个对象的引用。
         将对象的引用保持到volatile类型的域或者AtomicReference对象中。
         将对象的引用保存到某个正确构造对象的final类型域中。
         将对象的引用保存到一个由锁保护的域中。

        懒汉模式 / 饿汉模式  /

    final：
        1.修饰类:当用final修饰一个类时，表明这个类不能被继承。也就是说，如果一个类你永远不会让他被继承，就可以用final进行修饰。
          final类中的成员变量可以根据需要设为final，但是要注意final类中的所有成员方法都会被隐式地指定为final方法。

        2.修饰方法:使用final方法的原因有两个。第一个原因是把方法锁定，以防任何继承类修改它的含义；第二个原因是效率。
          在早期的Java实现版本中，会将final方法转为内嵌调用。但是如果方法过于庞大，可能看不到内嵌调用带来的任何性能提升。
          在最近的Java版本中，不需要使用final方法进行这些优化了。
          类的private方法会隐式地被指定为final方法。

        3.修饰变量: 这种用到的就比较多,对于final变量,如果是基本数据类型的变量，则其数值一旦在初始化之后便不能更改;
          如果是引用类型的变量，则在对其初始化之后便不能再让其指向另一个对象。